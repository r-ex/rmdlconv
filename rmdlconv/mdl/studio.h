// Copyright (c) 2022, rexx
// See LICENSE.txt for licensing information (GPL v3)

#pragma once

// This flag is set if no hitbox information was specified
#define STUDIOHDR_FLAGS_AUTOGENERATED_HITBOX	0x1

// NOTE:  This flag is set at loadtime, not mdl build time so that we don't have to rebuild
// models when we change materials.
#define STUDIOHDR_FLAGS_USES_ENV_CUBEMAP		0x2

// Use this when there are translucent parts to the model but we're not going to sort it 
#define STUDIOHDR_FLAGS_FORCE_OPAQUE			0x4

// Use this when we want to render the opaque parts during the opaque pass
// and the translucent parts during the translucent pass
#define STUDIOHDR_FLAGS_TRANSLUCENT_TWOPASS		0x8

// This is set any time the .qc files has $staticprop in it
// Means there's no bones and no transforms
#define STUDIOHDR_FLAGS_STATIC_PROP				0x10

// NOTE:  This flag is set at loadtime, not mdl build time so that we don't have to rebuild
// models when we change materials.
#define STUDIOHDR_FLAGS_USES_FB_TEXTURE		    0x20

// This flag is set by studiomdl.exe if a separate "$shadowlod" entry was present
//  for the .mdl (the shadow lod is the last entry in the lod list if present)
#define STUDIOHDR_FLAGS_HASSHADOWLOD			0x40

// NOTE:  This flag is set at loadtime, not mdl build time so that we don't have to rebuild
// models when we change materials.
#define STUDIOHDR_FLAGS_USES_BUMPMAPPING		0x80

// NOTE:  This flag is set when we should use the actual materials on the shadow LOD
// instead of overriding them with the default one (necessary for translucent shadows)
#define STUDIOHDR_FLAGS_USE_SHADOWLOD_MATERIALS	0x100

// NOTE:  This flag is set when we should use the actual materials on the shadow LOD
// instead of overriding them with the default one (necessary for translucent shadows)
#define STUDIOHDR_FLAGS_OBSOLETE				0x200

#define STUDIOHDR_FLAGS_UNUSED					0x400

// NOTE:  This flag is set at mdl build time
#define STUDIOHDR_FLAGS_NO_FORCED_FADE			0x800

// NOTE:  The npc will lengthen the viseme check to always include two phonemes
#define STUDIOHDR_FLAGS_FORCE_PHONEME_CROSSFADE	0x1000

// This flag is set when the .qc has $constantdirectionallight in it
// If set, we use constantdirectionallightdot to calculate light intensity
// rather than the normal directional dot product
// only valid if STUDIOHDR_FLAGS_STATIC_PROP is also set
#define STUDIOHDR_FLAGS_CONSTANT_DIRECTIONAL_LIGHT_DOT 0x2000

// Flag to mark delta flexes as already converted from disk format to memory format
#define STUDIOHDR_FLAGS_FLEXES_CONVERTED		0x4000

// Indicates the studiomdl was built in preview mode
#define STUDIOHDR_FLAGS_BUILT_IN_PREVIEW_MODE	0x8000

// Ambient boost (runtime flag)
#define STUDIOHDR_FLAGS_AMBIENT_BOOST			0x10000

// Don't cast shadows from this model (useful on first-person models)
#define STUDIOHDR_FLAGS_DO_NOT_CAST_SHADOWS		0x20000

// alpha textures should cast shadows in vrad on this model (ONLY prop_static!)
#define STUDIOHDR_FLAGS_CAST_TEXTURE_SHADOWS	0x40000

// Model has a quad-only Catmull-Clark SubD cage
#define STUDIOHDR_FLAGS_SUBDIVISION_SURFACE		0x80000

// flagged on load to indicate no animation events on this model
#define STUDIOHDR_FLAGS_NO_ANIM_EVENTS			0x100000

// If flag is set then studiohdr_t.flVertAnimFixedPointScale contains the
// scale value for fixed point vert anim data, if not set then the
// scale value is the default of 1.0 / 4096.0.  Regardless use
// studiohdr_t::VertAnimFixedPointScale() to always retrieve the scale value
#define STUDIOHDR_FLAGS_VERT_ANIM_FIXED_POINT_SCALE	0x200000

// sequence and autolayer flags
#define STUDIO_LOOPING	0x0001		// ending frame should be the same as the starting frame
#define STUDIO_SNAP		0x0002		// do not interpolate between previous animation and this one
#define STUDIO_DELTA	0x0004		// this sequence "adds" to the base sequences, not slerp blends
#define STUDIO_AUTOPLAY	0x0008		// temporary flag that forces the sequence to always play
#define STUDIO_POST		0x0010		// 
#define STUDIO_ALLZEROS	0x0020		// this animation/sequence has no real animation data
#define STUDIO_FRAMEANIM 0x0040		// animation is encoded as by frame x bone instead of RLE bone x frame
#define STUDIO_CYCLEPOSE 0x0080		// cycle index is taken from a pose parameter index
#define STUDIO_REALTIME	0x0100		// cycle index is taken from a real-time clock, not the animations cycle index
#define STUDIO_LOCAL	0x0200		// sequence has a local context sequence
#define STUDIO_HIDDEN	0x0400		// don't show in default selection views
#define STUDIO_OVERRIDE	0x0800		// a forward declared sequence (empty)
#define STUDIO_ACTIVITY	0x1000		// Has been updated at runtime to activity index
#define STUDIO_EVENT	0x2000		// Has been updated at runtime to event index on server
#define STUDIO_WORLD	0x4000		// sequence blends in worldspace
#define STUDIO_NOFORCELOOP 0x8000	// do not force the animation loop
#define STUDIO_EVENT_CLIENT 0x10000	// Has been updated at runtime to event index on client

// new in respawn models
#define STUDIO_ANIM_UNK3    0x0040  // used on something that is clearly not a frame anim in v54
									// animseq/humans/class/heavy/mp_pilot_heavy_core/mp_pt_crypto_base_execution_heavy_victim.rseq
#define STUDIO_ANIM_UNK		0x20000 // actually first in v52
#define STUDIO_ANIM_UNK1	0x40000
#define STUDIO_ANIM_UNK2	0x80000 // cherry blossom v53, levi in v54

#pragma pack(push, 1)
#define MAX_NUM_BONES_PER_VERT 3
#define MAX_NUM_LODS 8

struct Vertex_t
{
	// these index into the mesh's vert[origMeshVertID]'s bones
	unsigned char boneWeightIndex[MAX_NUM_BONES_PER_VERT];
	unsigned char numBones;

	unsigned short origMeshVertID;

	// for sw skinned verts, these are indices into the global list of bones
	// for hw skinned verts, these are hardware bone indices
	char boneID[MAX_NUM_BONES_PER_VERT];
};

struct StripHeader_t
{
	int numIndices;
	int indexOffset;

	int numVerts;
	int vertexOffset;

	short numBones;

	char stripFlags; // StripHeaderFlags_t

	int numBoneStateChanges;
	int boneStateChangeOffset;
	int numTopologyIndices;
	int topologyOffset;
};

struct StripGroupHeader_t
{
	// These are the arrays of all verts and indices for this mesh.  strips index into this.
	int numVerts;
	int vertOffset;

	Vertex_t* vert( int n) { return reinterpret_cast<Vertex_t*>((char*)this + vertOffset) + n; }

	int numIndices;
	int indexOffset;

	uint16_t* indices()
	{
		return reinterpret_cast<uint16_t*>((char*)this + indexOffset);
	}

	int numStrips;
	int stripOffset;

	StripHeader_t* strip(int i)
	{
		return reinterpret_cast<StripHeader_t*>((char*)this + stripOffset) + i;
	}

	unsigned char flags;

	int numTopologyIndices;
	int topologyOffset;
};

struct MeshHeader_t
{
	int numStripGroups;
	int stripGroupHeaderOffset;

	StripGroupHeader_t* stripGroup(int i)
	{
		return reinterpret_cast<StripGroupHeader_t*>((char*)this + stripGroupHeaderOffset) + i;
	}

	unsigned char flags;
};

struct ModelLODHeader_t
{
	int numMeshes;
	int meshOffset;
	float switchPoint;

	MeshHeader_t* mesh(int i)
	{
		return reinterpret_cast<MeshHeader_t*>((char*)this + meshOffset) + i;
	}
};

struct ModelHeader_t
{
	int numLODs;
	int lodOffset;

	ModelLODHeader_t* lod(int i)
	{
		return reinterpret_cast<ModelLODHeader_t*>((char*)this + lodOffset) + i;
	}
};

struct BodyPartHeader_t
{
	int numModels;
	int modelOffset;

	ModelHeader_t* model(int i)
	{
		return reinterpret_cast<ModelHeader_t*>((char*)this + modelOffset) + i;
	}
};


struct FileHeader_t
{
	// file version as defined by OPTIMIZED_MODEL_FILE_VERSION (currently 7)
	int version;

	// hardware params that affect how the model is to be optimized.
	int vertCacheSize;
	short maxBonesPerStrip;
	short maxBonesPerTri;
	int maxBonesPerVert;

	// must match checkSum in the .mdl
	int checksum;

	int numLODs; // Also specified in ModelHeader_t's and should match

	// Offset to materialReplacementList Array. one of these for each LOD, 8 in total
	int materialReplacementListOffset;

	// Defines the size and location of the body part array
	int numBodyParts;
	int bodyPartOffset;

	BodyPartHeader_t* bodyPart(int i)
	{
		return reinterpret_cast<BodyPartHeader_t*>((char*)this + bodyPartOffset) + i;
	}
};

struct mstudiopackedweight_t
{
	short weight[3];

	short pad; // what if

	int externalweightindex;
};

struct mstudioboneweight_t
{
	union {
		mstudiopackedweight_t packedweight; // complex weights (models with 4 or more weights per vert)
		float weight[MAX_NUM_BONES_PER_VERT]; // simple weights (models with 3 or less weights per vert)
	} weights;

	char bone[MAX_NUM_BONES_PER_VERT]; // set to unsigned so we can read it
	byte numbones; // if all three above are filled and this does not equal 3 there are four(?) weights
};

struct mstudiovertex_t
{
	mstudioboneweight_t	m_BoneWeights;
	Vector3			m_vecPosition;
	Vector3			m_vecNormal;
	Vector2			m_vecTexCoord;
};

struct vertexFileHeader_t
{
	int id; // MODEL_VERTEX_FILE_ID
	int version; // MODEL_VERTEX_FILE_VERSION
	int checksum; // same as studiohdr_t, ensures sync

	int numLODs; // num of valid lods
	int numLODVertexes[MAX_NUM_LODS]; // num verts for desired root lod

	int numFixups; // num of vertexFileFixup_t

	int fixupTableStart; // offset from base to fixup table
	int vertexDataStart; // offset from base to vertex block
	
	mstudiovertex_t* vertex(int i)
	{
		return reinterpret_cast<mstudiovertex_t*>((char*)this + vertexDataStart) + i;
	}

	int tangentDataStart; // offset from base to tangent block

	Vector4* tangent(int i)
	{
		return reinterpret_cast<Vector4*>((char*)this + tangentDataStart) + i;
	}
};

struct vertexColorFileHeader_t
{
	int id; // MODEL_VERTEX_FILE_ID
	int version; // MODEL_VERTEX_FILE_VERSION
	int checksum; // same as studiohdr_t, ensures sync

	int numLODs; // num of valid lods
	int numLODVertexes[MAX_NUM_LODS]; // num verts for desired root lod

	int colorDataStart;

	VertexColor_t* color(int i)
	{
		return reinterpret_cast<VertexColor_t*>((char*)this + colorDataStart) + i;
	}

	int uv2DataStart;

	Vector2* uv(int i)
	{
		return reinterpret_cast<Vector2*>((char*)this + uv2DataStart) + i;
	}
};
#pragma pack(pop)

struct mstudioanimsections_t
{
	int animblock; // index of animblock
	int animindex;
};

// used for piecewise loading of animation data
struct mstudioanimblock_t
{
	int datastart;
	int dataend;
};

struct mstudiojigglebone_t
{
	int flags;

	// general params
	float length; // how far from bone base, along bone, is tip
	float tipMass;

	// flexible params
	float yawStiffness;
	float yawDamping;
	float pitchStiffness;
	float pitchDamping;
	float alongStiffness;
	float alongDamping;

	// angle constraint
	float angleLimit; // maximum deflection of tip in radians

	// yaw constraint
	float minYaw; // in radians
	float maxYaw; // in radians
	float yawFriction;
	float yawBounce;

	// pitch constraint
	float minPitch; // in radians
	float maxPitch; // in radians
	float pitchFriction;
	float pitchBounce;

	// base spring
	float baseMass;
	float baseStiffness;
	float baseDamping;
	float baseMinLeft;
	float baseMaxLeft;
	float baseLeftFriction;
	float baseMinUp;
	float baseMaxUp;
	float baseUpFriction;
	float baseMinForward;
	float baseMaxForward;
	float baseForwardFriction;
};

struct mstudioattachment_t
{
	int sznameindex;
	int flags;

	int localbone; // parent bone

	matrix3x4_t localmatrix; // attachment point

	int	unused[8];
};

struct mstudiohitboxset_t
{
	int sznameindex;
	int numhitboxes;
	int hitboxindex;
};

struct mstudioposeparamdesc_t
{
	int					sznameindex;
	int					flags;	// ????
	float				start;	// starting value
	float				end;	// ending value
	float				loop;	// looping range, 0 for no looping, 360 for rotations, etc.
};

struct mstudioiklink_t
{
	int bone;
	Vector3	kneeDir; // ideal bending direction (per link, if applicable)
	Vector3	unused0; // unused in v49
};

struct mstudiotexturedir_t
{
	int sznameindex;
};

struct mstudiolinearbone_t
{
	int numbones;

	int flagsindex;

	int	parentindex;

	int	posindex;

	int quatindex;

	int rotindex;

	int posetoboneindex;

	int	posscaleindex; // unused in v53

	int	rotscaleindex;

	int	qalignmentindex;

	int unused[6];
};

struct mstudiosrcbonetransform_t
{
	int sznameindex;

	matrix3x4_t	pretransform;
	matrix3x4_t	posttransform;
};

struct mstudioikchain_t
{
	int sznameindex;
	int linktype;
	int numlinks;
	int linkindex;
};

struct mstudiomodelgroup_t
{
	int					szlabelindex;	// textual name
	int					sznameindex;	// file name
};

struct mstudiotexture_t
{
	int						sznameindex;

	int						flags;
	int						used;
	int						unused1;
	int material;  // fixme: this needs to go away . .isn't used by the engine, but is used by studiomdl
	int clientmaterial;	// gary, replace with client material pointer if used

	int						unused[10];
};

struct mstudio_modelvertexdata_t
{
	// both void* but studiomdl is 32-bit
	int pVertexData;
	int pTangentData;
};

struct mstudio_meshvertexdata_t
{
	// indirection to this mesh's model's vertex data
	int modelvertexdata;

	// used for fixup calcs when culling top level lods
	// expected number of mesh verts at desired lod
	int numLODVertexes[MAX_NUM_LODS];
};

struct mstudiomesh_t
{
	int material;

	int modelindex;

	int numvertices;		// number of unique vertices/normals/texcoords
	int vertexoffset;		// vertex mstudiovertex_t

	int numflexes;			// vertex animation
	int flexindex;

	// special codes for material operations
	int	materialtype;
	int	materialparam;

	// a unique ordinal for this mesh
	int	meshid;

	Vector3	center;

	mstudio_meshvertexdata_t vertexdata;

	int	unused[8]; // remove as appropriate
};

struct mstudiomodel_t
{
	char name[64];

	int type;

	float boundingradius;

	int	nummeshes;
	int	meshindex;
	// cache purposes
	int	numvertices;		// number of unique vertices/normals/texcoords
	int	vertexindex;		// vertex Vector
	int	tangentsindex;		// tangents Vector

	int numattachments;
	int attachmentindex;

	int numeyeballs;
	int eyeballindex;

	mstudio_modelvertexdata_t vertexdata;

	int unused[8];		// remove as appropriate
};

struct mstudiobbox_t
{
	int					bone;
	int					group;				// intersection group
	Vector3				bbmin;				// bounding box
	Vector3				bbmax;
	int					szhitboxnameindex;	// offset to the name of the hitbox.
	int					unused[8];
};

struct mstudiobone_t
{
	int					sznameindex;

	int		 			parent;		// parent bone
	int					bonecontroller[6];	// bone controller index, -1 == none

	// default values
	Vector3				pos;
	Quaternion			quat;
	RadianEuler			rot;
	// compression scale
	Vector3				posscale;
	Vector3				rotscale;

	matrix3x4_t			poseToBone;
	Quaternion			qAlignment;
	int					flags;
	int					proctype;
	int					procindex;		// procedural rule
	int			physicsbone;	// index into physically simulated bone

	int					surfacepropidx;	// index into string tablefor property name

	int					contents;		// See BSPFlags.h for the contents flags
	int					surfacepropLookup;	// this index must be cached by the loader, not saved in the file
	int					unused[7];		// remove as appropriate
};

struct studiohdr2_t
{
	// NOTE: For forward compat, make sure any methods in this struct
	// are also available in studiohdr_t so no leaf code ever directly references
	// a studiohdr2_t structure
	int numsrcbonetransform;
	int srcbonetransformindex;
	inline mstudiosrcbonetransform_t* pSrcBoneTransforms() const { return (mstudiosrcbonetransform_t*)((byte*)this) + srcbonetransformindex; }

	int	illumpositionattachmentindex;

	float flMaxEyeDeflection;

	int linearboneindex;
	inline mstudiolinearbone_t* pLinearBones() const { return (linearboneindex) ? (mstudiolinearbone_t*)(((byte*)this) + linearboneindex) : NULL; }

	int sznameindex;
	inline char* pszName() const { return (char*)((byte*)this + sznameindex); };

	int m_nBoneFlexDriverCount;
	int m_nBoneFlexDriverIndex;

	int reserved[56];
};

struct studiohdr_t
{
	int					id;
	int					version;

	long				checksum;		// this has to be the same in the phy and vtx files to load!

	char				name[64];

	int					length;

	Vector3				eyeposition;	// ideal eye position

	Vector3				illumposition;	// illumination center

	Vector3				hull_min;		// ideal movement hull size
	Vector3				hull_max;

	Vector3				view_bbmin;		// clipping bounding box
	Vector3				view_bbmax;

	int					flags;

	int					numbones;			// bones
	int					boneindex;

	int					numbonecontrollers;		// bone controllers
	int					bonecontrollerindex;

	int					numhitboxsets;
	int					hitboxsetindex;

	// file local animations? and sequences
//private:
	int					numlocalanim;			// animations/poses
	int					localanimindex;		// animation descriptions

	int					numlocalseq;				// sequences
	int					localseqindex;

	//private:
	int			activitylistversion;	// initialization flag - have the sequences been indexed?
	int			eventsindexed;

	// raw textures
	int					numtextures;
	int					textureindex;

	// raw textures search paths
	int					numcdtextures;
	int					cdtextureindex;

	// replaceable textures tables
	int					numskinref;
	int					numskinfamilies;
	int					skinindex;

	int					numbodyparts;
	int					bodypartindex;

	// queryable attachable points
//private:
	int					numlocalattachments;
	int					localattachmentindex;


	// animation node to animation node transition graph
	int					numlocalnodes;
	int					localnodeindex;
	int					localnodenameindex;

	int					numflexdesc;
	int					flexdescindex;

	int					numflexcontrollers;
	int					flexcontrollerindex;

	int					numflexrules;
	int					flexruleindex;

	int					numikchains;
	int					ikchainindex;

	int					nummouths;
	int					mouthindex;

	//private:
	int					numlocalposeparameters;
	int					localposeparamindex;


	int					surfacepropindex;


	// Key values
	int					keyvalueindex;
	int					keyvaluesize;

	int					numlocalikautoplaylocks;
	int					localikautoplaylockindex;


	// The collision model mass that jay wanted
	float				mass;
	int					contents;

	// external animations, models, etc.
	int					numincludemodels;
	int					includemodelindex;

	// implementation specific call to get a named model

	// implementation specific back pointer to virtual data
	int /* mutable void* */ virtualModel;

	// for demand loaded animation blocks
	int					szanimblocknameindex;

	int					numanimblocks;
	int					animblockindex;

	int /* mutable void* */ animblockModel;

	int					bonetablebynameindex;

	// used by tools only that don't cache, but persist mdl's peer data
	// engine uses virtualModel to back link to cache pointers
	int /* void* */ pVertexBase;
	int /* void* */ pIndexBase;

	// if STUDIOHDR_FLAGS_CONSTANT_DIRECTIONAL_LIGHT_DOT is set,
	// this value is used to calculate directional components of lighting 
	// on static props
	byte				constdirectionallightdot;

	// set during load of mdl data to track *desired* lod configuration (not actual)
	// the *actual* clamped root lod is found in studiohwdata
	// this is stored here as a global store to ensure the staged loading matches the rendering
	byte				rootLOD;

	// set in the mdl data to specify that lod configuration should only allow first numAllowRootLODs
	// to be set as root LOD:
	//	numAllowedRootLODs = 0	means no restriction, any lod can be set as root lod.
	//	numAllowedRootLODs = N	means that lod0 - lod(N-1) can be set as root lod, but not lodN or lower.
	byte				numAllowedRootLODs;

	byte				unused[1];

	int					unused4;

	int					numflexcontrollerui;
	int					flexcontrolleruiindex;

	float				flVertAnimFixedPointScale;
	mutable int			surfacepropLookup;	// this index must be cached by the loader, not saved in the file

	// FIXME: Remove when we up the model version. Move all fields of studiohdr2_t into studiohdr_t.
	int					studiohdr2index;
	studiohdr2_t* pStudioHdr2() const { return (studiohdr2_t*)(((byte*)this) + studiohdr2index); }

	inline char* pszName() const{ return pStudioHdr2()->pszName(); };

	// NOTE: No room to add stuff? Up the .mdl file format version 
	// [and move all fields in studiohdr2_t into studiohdr_t and kill studiohdr2_t],
	// or add your stuff to studiohdr2_t. See NumSrcBoneTransforms/SrcBoneTransform for the pattern to use.
	int					unused2[1];
};

namespace r1
{
	// struct names are assumptions
	struct mstudioaabbheader_t
	{
		int version; // unsure if this is an actual version or type
					 // set to '2' for static prop.

		// aabb sizes, same as hulls
		Vector3 bbmin;
		Vector3 bbmax;

		int unused[8]; // hopefully, checks out with other mdl structs 
	};

	struct mstudioaabbnode_t
	{
		short unk[3];
		short unk1[3];

		// sometimes negative
		int unk2[2];
	};

	struct aabbtype
	{
		short unk[3];
		short unk1;
	};

	struct mstudioaabbleaf_t
	{
		short unk[6];

		int unk1;

		aabbtype unk2[12];
	};

	struct mstudioaabbvert_t
	{
		char vertex[6]; // format is unknown
	};

	struct studiohdr2_t
	{
		int numsrcbonetransform;
		int srcbonetransformindex;
		//inline mstudiosrcbonetransform_t* pSrcBoneTransforms() const { return (mstudiosrcbonetransform_t*)(((byte*)this) + srcbonetransformindex); }

		int	illumpositionattachmentindex;

		float flMaxEyeDeflection;

		int linearboneindex;
		inline mstudiolinearbone_t* pLinearBones() const { return (linearboneindex) ? (mstudiolinearbone_t*)(((byte*)this) + linearboneindex) : NULL; }

		int sznameindex;
		inline char* pszName() const { return (char*)((byte*)this + sznameindex); };

		int m_nBoneFlexDriverCount;
		int m_nBoneFlexDriverIndex;

		// for static props (and maybe others)
		// Precomputed Per-Triangle AABB data
		int m_nPerTriAABBIndex;
		int m_nPerTriAABBNodeCount;
		int m_nPerTriAABBLeafCount;
		int m_nPerTriAABBVertCount;
		inline r1::mstudioaabbheader_t* pPerTriAABB() const { return (r1::mstudioaabbheader_t*)(((byte*)this) + m_nPerTriAABBIndex); }

		// always "" or "Titan"
		int unkstringindex;
		inline char* pszUnkString() const { return (char*)((byte*)this + unkstringindex); };

		int reserved[39];
	};

	struct studiohdr_t
	{
		int id; // Model format ID, such as "IDST" (0x49 0x44 0x53 0x54)
		int version; // Format version number, such as 48 (0x30,0x00,0x00,0x00)
		int checksum; // This has to be the same in the phy and vtx files to load!
		char name[64]; // The internal name of the model, padding with null bytes.
						// Typically "my_model.mdl" will have an internal name of "my_model"
		int length; // Data size of MDL file in bytes.

		Vector3 eyeposition;	// ideal eye position

		Vector3 illumposition;	// illumination center

		Vector3 hull_min;		// ideal movement hull size
		Vector3 hull_max;

		Vector3 view_bbmin;		// clipping bounding box
		Vector3 view_bbmax;

		int flags;

		// highest observed: 250
		int numbones; // bones
		int boneindex;

		int numbonecontrollers; // bone controllers
		int bonecontrollerindex;

		int numhitboxsets;
		int hitboxsetindex;

		int numlocalanim; // animations/poses
		int localanimindex; // animation descriptions

		int numlocalseq; // sequences
		int	localseqindex;

		int activitylistversion; // initialization flag - have the sequences been indexed?
		int eventsindexed;

		// raw textures
		int numtextures;
		int textureindex;

		/// raw textures search paths
		int numcdtextures;
		int cdtextureindex;

		// replaceable textures tables
		int numskinref;
		int numskinfamilies;
		int skinindex;

		int numbodyparts;
		int bodypartindex;

		int numlocalattachments;
		int localattachmentindex;

		int numlocalnodes;
		int localnodeindex;
		int localnodenameindex;

		int deprecated_numflexdesc;
		int deprecated_flexdescindex;

		int deprecated_numflexcontrollers;
		int deprecated_flexcontrollerindex;

		int deprecated_numflexrules;
		int deprecated_flexruleindex;

		int numikchains;
		int ikchainindex;

		int deprecated_nummouths;
		int deprecated_mouthindex;

		int numlocalposeparameters;
		int localposeparamindex;

		int surfacepropindex;

		int keyvalueindex;
		int keyvaluesize;

		int numlocalikautoplaylocks;
		int localikautoplaylockindex;


		float mass;
		int contents;

		// external animations, models, etc.
		int numincludemodels;
		int includemodelindex;

		// implementation specific back pointer to virtual data
		int /* mutable void* */ virtualModel;

		// for demand loaded animation blocks
		int szanimblocknameindex;

		int numanimblocks;
		int animblockindex;

		int /* mutable void* */ animblockModel;

		int bonetablebynameindex;

		// used by tools only that don't cache, but persist mdl's peer data
		// engine uses virtualModel to back link to cache pointers
		int /* void* */ pVertexBase;
		int /* void* */ pIndexBase;

		// if STUDIOHDR_FLAGS_CONSTANT_DIRECTIONAL_LIGHT_DOT is set,
		// this value is used to calculate directional components of lighting 
		// on static props
		byte constdirectionallightdot;

		// set during load of mdl data to track *desired* lod configuration (not actual)
		// the *actual* clamped root lod is found in studiohwdata
		// this is stored here as a global store to ensure the staged loading matches the rendering
		byte rootLOD;

		// set in the mdl data to specify that lod configuration should only allow first numAllowRootLODs
		// to be set as root LOD:
		//	numAllowedRootLODs = 0	means no restriction, any lod can be set as root lod.
		//	numAllowedRootLODs = N	means that lod0 - lod(N-1) can be set as root lod, but not lodN or lower.
		byte numAllowedRootLODs;

		byte unused;

		float fadeDistance;

		int deprecated_numflexcontrollerui;
		int deprecated_flexcontrolleruiindex;

		float flVertAnimFixedPointScale;
		int surfacepropLookup;	// this index must be cached by the loader, not saved in the file

		// NOTE: No room to add stuff? Up the .mdl file format version 
		// [and move all fields in studiohdr2_t into studiohdr_t and kill studiohdr2_t],
		// or add your stuff to studiohdr2_t. See NumSrcBoneTransforms/SrcBoneTransform for the pattern to use.
		int studiohdr2index;
		studiohdr2_t* pStudioHdr2() const { return (studiohdr2_t*)(((byte*)this) + studiohdr2index); }

		inline char* pszName() const { return pStudioHdr2()->pszName(); };
		inline char* pszUnkString() const { return pStudioHdr2()->pszUnkString(); };

		int sourceFilenameOffset; // in v52 not every model has these strings, only four bytes when not present.
	};

	struct mstudiobone_t
	{
		int sznameindex;

		int parent; // parent bone
		int bonecontroller[6]; // bone controller index, -1 == none

		// default values
		Vector3 pos; // base bone position
		Quaternion quat;
		RadianEuler rot; // base bone rotation

		// compression scale
		Vector3 posscale; // scale muliplier for bone position in animations
		Vector3 rotscale; // scale muliplier for bone rotation in animations

		matrix3x4_t poseToBone;
		Quaternion qAlignment;

		int flags;
		int proctype;
		int procindex; // procedural rule offset
		int physicsbone; // index into physically simulated bone

		int surfacepropidx; // index into string tablefor property name

		int contents; // See BSPFlags.h for the contents flags

		int surfacepropLookup; // this index must be cached by the loader, not saved in the file

		// bone scale(?)
		Vector3 scale;
		Vector3 scalescale;

		int unused; // remove as appropriate
	};

	struct mstudioanimdesc_t
	{
		int baseptr;

		int sznameindex;

		float fps; // frames per second	
		int flags; // looping/non-looping flags

		int numframes;

		// piecewise movement
		int	nummovements;
		int movementindex;

		int ikrulezeroframeindex;

		int framemovementindex; // new in v52

		int unused1[4]; // remove as appropriate (and zero if loading older versions)	

		int animblock;
		int animindex; // non-zero when anim data isn't in sections

		int numikrules;
		int ikruleindex; // non-zero when IK data is stored in the mdl
		int animblockikruleindex; // non-zero when IK data is stored in animblock file

		int numlocalhierarchy;
		int localhierarchyindex;;

		int sectionindex;
		int sectionframes; // number of frames used in each fast lookup section, zero if not used

		short zeroframespan; // frames per span
		short zeroframecount; // number of spans
		int zeroframeindex;

		float zeroframestalltime; // saved during read stalls
	};

	#define STUDIO_FRAME_RAWPOS		0x01 // Vector48 in constants
	#define STUDIO_FRAME_RAWROT		0x02 // Quaternion48 in constants
	#define STUDIO_FRAME_RAWSCALE	0x04 // Vector48 in constants
	#define STUDIO_FRAME_ANIMPOS	0x08 // Quaternion48 in framedata
	#define STUDIO_FRAME_ANIMROT	0x10 // Vector48 in framedata
	#define STUDIO_FRAME_ANIMSCALE	0x20 // Vector48 in framedata

	struct mstudio_frame_anim_t
	{
		int constantsoffset;

		int frameoffset;
		int framelength;

		int fixedOldBoneflags;

		int unkdataindex; // indexes into array of values that somewhat relate to flags

		int unused;
	};

	// per bone
	struct unkframeanimdata_t
	{
		short unkframe; // advances by six when bone has flags for frame data
		short unkconstant; // advances by six when bone has flags for constant data
	};

	struct mstudioikrule_t
	{
		int index;

		int type;
		int chain;

		int	bone;

		int slot;	// iktarget slot.  Usually same as chain.
		float height;
		float radius;
		float floor;
		Vector3 pos;
		Quaternion q;

		int compressedikerrorindex;

		int unused2;

		int iStart;
		int ikerrorindex;

		float start;	// beginning of influence
		float peak;	// start of full influence
		float tail;	// end of full influence
		float end;	// end of all influence

		float unused3;	// 
		float contact;	// frame footstep makes ground concact
		float drop;		// how far down the foot should drop when reaching for IK
		float top;		// top of the foot box

		int unused6;
		int unused7;
		int unused8;

		int szattachmentindex;		// name of world attachment

		float endHeight; // new in v52

		int unused[6];
	};

	struct mstudioseqdesc_t
	{
		int baseptr;

		int	szlabelindex;

		int szactivitynameindex;

		int flags; // looping/non-looping flags

		int activity; // initialized at loadtime to game DLL values
		int actweight;

		int numevents;
		int eventindex;

		Vector3 bbmin; // per sequence bounding box
		Vector3 bbmax;

		int numblends;

		// Index into array of shorts which is groupsize[0] x groupsize[1groupsize[1] in length
		int animindexindex;

		int movementindex; // [blend] float array for blended movement
		int groupsize[2];
		int paramindex[2]; // X, Y, Z, XR, YR, ZR
		float paramstart[2]; // local (0..1) starting value
		float paramend[2]; // local (0..1) ending value
		int paramparent;

		float fadeintime; // ideal cross fate in time (0.2 default)
		float fadeouttime; // ideal cross fade out time (0.2 default)

		int localentrynode; // transition node at entry
		int localexitnode; // transition node at exit
		int nodeflags; // transition rules

		float entryphase; // used to match entry gait
		float exitphase; // used to match exit gait

		float lastframe; // frame that should generation EndOfSequence

		int nextseq; // auto advancing sequences
		int pose; // index of delta animation between end and nextseq

		int numikrules;

		int numautolayers;
		int autolayerindex;

		int weightlistindex;

		int posekeyindex;

		int numiklocks;
		int iklockindex;

		// Key values
		int	keyvalueindex;
		int keyvaluesize;

		int cycleposeindex; // index of pose parameter to use as cycle index

		int activitymodifierindex;
		int numactivitymodifiers;

		int ikResetMask; // new in v52
		int unk1; // count? STUDIO_ANIMDESC_52_UNK?? ikReset (what above var is masking)

		int unused[3];
	};

	// aligned to four bytes
	#pragma pack(push, 4)
	struct mstudioactivitymodifier_t
	{
		int sznameindex;

		bool negate; // negate all other activity modifiers when this one is active?
	};
	#pragma pack(pop)

	struct mstudiomodel_t
	{
		char name[64];

		int type;

		float boundingradius;

		int nummeshes;
		int meshindex;

		// cache purposes
		int numvertices; // number of unique vertices/normals/texcoords
		int vertexindex; // vertex Vector
						 // offset by vertexindex number of bytes into vvd verts
		int tangentsindex; // tangents Vector
						   // offset by tangentsindex number of bytes into vvd tangents

		int numattachments;
		int attachmentindex;

		int deprecated_numeyeballs;
		int deprecated_eyeballindex;

		int pad[4];

		int colorindex; // vertex color
						// offset by colorindex number of bytes into vvc vertex colors
		int uv2index; // vertex second uv map
					  // offset by uv2index number of bytes into vvc secondary uv map

		int unused[4];
	};

	struct mstudiomesh_t
	{
		int material;

		int modelindex;

		int numvertices; // number of unique vertices/normals/texcoords
		int vertexoffset; // vertex mstudiovertex_t
						  // offset by vertexoffset number of verts into vvd vertexes, relative to the models offset

		// Access thin/fat mesh vertex data (only one will return a non-NULL result)

		int deprecated_numflexes; // vertex animation
		int deprecated_flexindex;

		// special codes for material operations
		int deprecated_materialtype;
		int deprecated_materialparam;

		// a unique ordinal for this mesh
		int meshid;

		Vector3 center;

		mstudio_meshvertexloddata_t vertexloddata;

		int unused[8]; // remove as appropriate
	};

	struct mstudiotexture_t
	{
		int sznameindex;

		int unused_flags;
		int used;
		int unused1;

		int material;
		int clientmaterial;

		int unused[10];
	};
}

namespace r2
{
	struct studiohdr_t
	{
		int id; // Model format ID, such as "IDST" (0x49 0x44 0x53 0x54)
		int version; // Format version number, such as 48 (0x30,0x00,0x00,0x00)
		int checksum; // This has to be the same in the phy and vtx files to load!
		int sznameindex; // This has been moved from studiohdr2 to the front of the main header.
		char name[64]; // The internal name of the model, padding with null bytes.
		// Typically "my_model.mdl" will have an internal name of "my_model"
		int length; // Data size of MDL file in bytes.

		Vector3 eyeposition;	// ideal eye position

		Vector3 illumposition;	// illumination center

		Vector3 hull_min;		// ideal movement hull size
		Vector3 hull_max;

		Vector3 view_bbmin;		// clipping bounding box
		Vector3 view_bbmax;

		int flags;

		// highest observed: 250
		// max is definitely 256 because 8bit uint limit
		int numbones; // bones
		int boneindex;

		int numbonecontrollers; // bone controllers
		int bonecontrollerindex;

		int numhitboxsets;
		int hitboxsetindex;

		int numlocalanim; // animations/poses
		int localanimindex; // animation descriptions

		int numlocalseq; // sequences
		int	localseqindex;

		int activitylistversion; // initialization flag - have the sequences been indexed? set on load
		int eventsindexed;

		// mstudiotexture_t
		// short rpak path
		// raw textures
		int numtextures; // the material limit exceeds 128, probably 256.
		int textureindex;

		// this should always only be one, unless using vmts.
		// raw textures search paths
		int numcdtextures;
		int cdtextureindex;

		// replaceable textures tables
		int numskinref;
		int numskinfamilies;
		int skinindex;

		int numbodyparts;
		int bodypartindex;

		int numlocalattachments;
		int localattachmentindex;

		int numlocalnodes;
		int localnodeindex;
		int localnodenameindex;

		int deprecated_numflexdesc;
		int deprecated_flexdescindex;

		int deprecated_numflexcontrollers;
		int deprecated_flexcontrollerindex;

		int deprecated_numflexrules;
		int deprecated_flexruleindex;

		int numikchains;
		int ikchainindex;

		int numruimeshes;
		int ruimeshindex;

		int numlocalposeparameters;
		int localposeparamindex;

		int surfacepropindex; // string index

		int keyvalueindex;
		int keyvaluesize;

		int numlocalikautoplaylocks;
		int localikautoplaylockindex;

		float mass;
		int contents;

		// external animations, models, etc.
		int numincludemodels;
		int includemodelindex;

		uint32_t virtualModel;

		// animblock is either completely cut, this is because they no longer use .ani files.

		int bonetablebynameindex;

		// if STUDIOHDR_FLAGS_CONSTANT_DIRECTIONAL_LIGHT_DOT is set,
		// this value is used to calculate directional components of lighting 
		// on static props
		byte constdirectionallightdot;

		// set during load of mdl data to track *desired* lod configuration (not actual)
		// the *actual* clamped root lod is found in studiohwdata
		// this is stored here as a global store to ensure the staged loading matches the rendering
		byte rootLOD;

		// set in the mdl data to specify that lod configuration should only allow first numAllowRootLODs
		// to be set as root LOD:
		//	numAllowedRootLODs = 0	means no restriction, any lod can be set as root lod.
		//	numAllowedRootLODs = N	means that lod0 - lod(N-1) can be set as root lod, but not lodN or lower.
		byte numAllowedRootLODs;

		byte unused;

		float fadeDistance; // set to -1 to never fade. set above 0 if you want it to fade out, distance is in feet.
		// player/titan models seem to inherit this value from the first model loaded in menus.
		// works oddly on entities, probably only meant for static props

		int deprecated_numflexcontrollerui;
		int deprecated_flexcontrolleruiindex;

		float flVertAnimFixedPointScale;
		int surfacepropLookup; // this index must be cached by the loader, not saved in the file

		// this is in all shipped models, probably part of their asset bakery. it should be 0x2CC.
		// doesn't actually need to be written pretty sure, only four bytes when not present.
		// this is not completely true as some models simply have nothing, such as animation models.
		int sourceFilenameOffset;

		int numsrcbonetransform;
		int srcbonetransformindex;

		int	illumpositionattachmentindex;

		int linearboneindex;

		int m_nBoneFlexDriverCount;
		int m_nBoneFlexDriverIndex;

		// for static props (and maybe others)
		// Precomputed Per-Triangle AABB data
		int m_nPerTriAABBIndex;
		int m_nPerTriAABBNodeCount;
		int m_nPerTriAABBLeafCount;
		int m_nPerTriAABBVertCount;

		// always "" or "Titan"
		int unkstringindex; // string index

		// ANIs are no longer used and this is reflected in many structs
		// Start of internal file data
		int vtxindex; // VTX
		int vvdindex; // VVD / IDSV
		int vvcindex; // VVC / IDCV 
		int vphyindex; // VPHY / IVPS

		int vtxsize; // VTX
		int vvdsize; // VVD / IDSV
		int vvcsize; // VVC / IDCV 
		int vphysize; // VPHY / IVPS

		// this data block is related to the vphy, if it's not present the data will not be written
		// definitely related to phy, apex phy has this merged into it
		int unkmemberindex1; // section between vphy and vtx.?
		int numunkmember1; // only seems to be used when phy has one solid

		// only seen on '_animated' suffixed models so far
		int unkcount3;
		int unkindex3;

		int unused1[60];

	};

	struct mstudiobone_t
	{
		int sznameindex;

		int parent; // parent bone
		int bonecontroller[6]; // bone controller index, -1 == none

		// default values
		Vector3 pos; // base bone position
		Quaternion quat;
		RadianEuler rot; // base bone rotation
		Vector3 scale; // bone scale(?)

		// compression scale
		Vector3 posscale; // scale muliplier for bone position in animations. deprecated in v53, as the posscale is stored in anim bone headers
		Vector3 rotscale; // scale muliplier for bone rotation in animations
		Vector3 scalescale; // scale muliplier for scale

		matrix3x4_t poseToBone;
		Quaternion qAlignment;

		int flags;
		int proctype;
		int procindex; // procedural rule offset
		int physicsbone; // index into physically simulated bone

		int surfacepropidx; // index into string tablefor property name

		int contents; // See BSPFlags.h for the contents flags

		int surfacepropLookup; // this index must be cached by the loader, not saved in the file

		// unknown phy related section
		short unkindex; // index into this section
		short unkcount; // number of sections for this bone?? see: models\s2s\s2s_malta_gun_animated.mdl

		int unused[7]; // remove as appropriate
	};

	struct mstudiobbox_t
	{
		int bone;
		int group; // intersection group

		Vector3 bbmin; // bounding box
		Vector3 bbmax;

		int szhitboxnameindex; // offset to the name of the hitbox.

		int critoverride; // overrides the group to be a crit, 0 or 1. might be group override since group 1 is head.

		int keyvalueindex; // used for keyvalues, most for titans.

		int unused[6];
	};

	struct mstudioanimsections_t
	{
		int animindex;
	};

	struct mstudiomesh_t
	{
		int material;

		int modelindex;

		int numvertices; // number of unique vertices/normals/texcoords
		int vertexoffset; // vertex mstudiovertex_t
		// offset by vertexoffset number of verts into vvd vertexes, relative to the models offset

		// Access thin/fat mesh vertex data (only one will return a non-NULL result)

		int deprecated_numflexes; // vertex animation
		int deprecated_flexindex;

		// special codes for material operations
		int deprecated_materialtype;
		int deprecated_materialparam;

		// a unique ordinal for this mesh
		int meshid;

		Vector3 center;

		mstudio_meshvertexloddata_t vertexloddata;

		char unk[8]; // set on load

		int unused[6]; // remove as appropriate
	};

	struct mstudioikchain_t
	{
		int sznameindex;

		int linktype;
		int numlinks;
		int linkindex;

		float unk; // no clue what this does tbh, tweaking it does nothing
				   // default value: 0.707f

		int unused[3]; // these get cut in apex so I can't imagine this is used
	};

	struct mstudiotexture_t
	{
		int sznameindex;
		int unused_flags;
		int used; // whar?
		int unused[8];
	};
}

#define STRING_FROM_IDX(base, idx) reinterpret_cast<const char*>((char*)base + idx)
#define PTR_FROM_IDX(type, base, idx) reinterpret_cast<type*>((char*)base + idx)

struct stringentry_t
{
	char* base;
	char* addr;
	int* ptr;
	const char* string;
	int dupindex;
};

struct s_modeldata_t
{
	//r5::v8::studiohdr_t* pHdr;
	void* pHdr;
	inline r5::v8::studiohdr_t* hdrV54() { return reinterpret_cast<r5::v8::studiohdr_t*>(pHdr); }
	inline r2::studiohdr_t* hdrV53() { return reinterpret_cast<r2::studiohdr_t*>(pHdr); }

	std::vector<stringentry_t> stringTable;
	char* pBase;
	char* pData;
};

inline s_modeldata_t g_model;

static void BeginStringTable()
{
	g_model.stringTable.emplace_back(stringentry_t{ NULL, NULL, NULL, "", -1 });
}

static void AddToStringTable(char* base, int* ptr, const char* string)
{
	if (!string)
		string = "";

	stringentry_t newString{};

	int i = 0;
	for(auto&it: g_model.stringTable)
	{
		if (!strcmp(string, it.string))
		{
			newString.base = (char*)base;
			newString.ptr = ptr;
			newString.string = string;
			newString.dupindex = i;
			g_model.stringTable.emplace_back(newString);
			return;
		}
		i++;
	}

	newString.base = (char*)base;
	newString.ptr = ptr;
	newString.string = string;
	newString.dupindex = -1;

	g_model.stringTable.emplace_back(newString);
}

static char* WriteStringTable(char* pData)
{
	auto& stringTable = g_model.stringTable;

	for (auto& it : stringTable)
	{
		// if first time the string is added to the table (unique or first version of duplicated strings)
		if (it.dupindex == -1)
		{
			it.addr = pData;

			if (it.ptr)
			{
				*it.ptr = pData - it.base;
				
				int length = strlen(it.string);
				strcpy_s(pData, length+1, it.string);

				pData += length;
			}

			*pData = '\0';

			pData++;
		}
		else
		{
			// if string is a duplicate entry
			// find the offset from the var's base ptr to the initial instance of the string
			*it.ptr = stringTable[it.dupindex].addr - it.base;
		}
	}

	return pData;
}

// for converting attachments between normal mdl versions
// used for: mdl v52/v53 conversions
static int ConvertAttachmentsToMDL(mstudioattachment_t* pOldAttachments, int numAttachments)
{
	int index = g_model.pData - g_model.pBase;

	printf("converting %i attachments...\n", numAttachments);

	for (int i = 0; i < numAttachments; ++i)
	{
		mstudioattachment_t* oldAttach = &pOldAttachments[i];

		mstudioattachment_t* attach = reinterpret_cast<mstudioattachment_t*>(g_model.pData) + i;

		AddToStringTable((char*)attach, &attach->sznameindex, STRING_FROM_IDX(oldAttach, oldAttach->sznameindex));
		attach->flags = oldAttach->flags;
		attach->localbone = oldAttach->localbone;
		memcpy(&attach->localmatrix, &oldAttach->localmatrix, sizeof(oldAttach->localmatrix));
	}
	g_model.pData += numAttachments * sizeof(mstudioattachment_t);

	return index;

	ALIGN4(g_model.pData);
}

// for converting mdl attachments to rmdl attachments
// used for: all v54 conversions
static int ConvertAttachmentTo54(mstudioattachment_t* pOldAttachments, int numAttachments)
{
	int index = g_model.pData - g_model.pBase;

	printf("converting %i attachments...\n", numAttachments);

	for (int i = 0; i < numAttachments; ++i)
	{
		mstudioattachment_t* oldAttach = &pOldAttachments[i];

		r5::v8::mstudioattachment_t* attach = reinterpret_cast<r5::v8::mstudioattachment_t*>(g_model.pData) + i;

		AddToStringTable((char*)attach, &attach->sznameindex, STRING_FROM_IDX(oldAttach, oldAttach->sznameindex));
		attach->flags = oldAttach->flags;
		attach->localbone = oldAttach->localbone;
		memcpy(&attach->localmatrix, &oldAttach->localmatrix, sizeof(oldAttach->localmatrix));
	}
	g_model.pData += numAttachments * sizeof(r5::v8::mstudioattachment_t);

	return index;

	ALIGN4(g_model.pData);
}

static int ConvertPoseParams(mstudioposeparamdesc_t* pOldPoseParams, int numPoseParams, bool isRig)
{
	int index = g_model.pData - g_model.pBase;

	//if (!isRig)
	//	return;

	printf("converting %i poseparams...\n", numPoseParams);

	for (int i = 0; i < numPoseParams; i++)
	{
		mstudioposeparamdesc_t* oldPose = &pOldPoseParams[i];
		mstudioposeparamdesc_t* newPose = reinterpret_cast<mstudioposeparamdesc_t*>(g_model.pData);

		AddToStringTable((char*)newPose, &newPose->sznameindex, STRING_FROM_IDX(oldPose, oldPose->sznameindex));

		newPose->flags = oldPose->flags;
		newPose->start = oldPose->start;
		newPose->end = oldPose->end;
		newPose->loop = oldPose->loop;

		g_model.pData += sizeof(mstudioposeparamdesc_t);
	}

	return index;

	ALIGN4(g_model.pData);
}

static int ConvertSrcBoneTransforms(mstudiosrcbonetransform_t* pOldBoneTransforms, int numSrcBoneTransforms)
{
	int index = g_model.pData - g_model.pBase;

	printf("converting %i bone transforms...\n", numSrcBoneTransforms);

	for (int i = 0; i < numSrcBoneTransforms; i++)
	{
		mstudiosrcbonetransform_t* oldTransform = &pOldBoneTransforms[i];

		mstudiosrcbonetransform_t* newTransform = reinterpret_cast<mstudiosrcbonetransform_t*>(g_model.pData);

		AddToStringTable((char*)newTransform, &newTransform->sznameindex, STRING_FROM_IDX(oldTransform, oldTransform->sznameindex));

		newTransform->pretransform = oldTransform->pretransform;
		newTransform->posttransform = oldTransform->posttransform;

		g_model.pData += sizeof(mstudiosrcbonetransform_t);
	}

	return index;

	ALIGN4(g_model.pData);
}

// specifically for v54
static void ConvertLinearBoneTableTo54(mstudiolinearbone_t* pOldLinearBone, char* pOldLinearBoneTable)
{
	printf("converting linear bone table...\n");

	g_model.hdrV54()->linearboneindex = g_model.pData - g_model.pBase;

	r5::v8::mstudiolinearbone_t* newLinearBone = reinterpret_cast<r5::v8::mstudiolinearbone_t*>(g_model.pData);
	g_model.pData += sizeof(r5::v8::mstudiolinearbone_t);

	newLinearBone->numbones = pOldLinearBone->numbones;
	newLinearBone->flagsindex = pOldLinearBone->flagsindex - 36;
	newLinearBone->parentindex = pOldLinearBone->parentindex - 36;
	newLinearBone->posindex = pOldLinearBone->posindex - 36;
	newLinearBone->quatindex = pOldLinearBone->quatindex - 36;
	newLinearBone->rotindex = pOldLinearBone->rotindex - 36;
	newLinearBone->posetoboneindex = pOldLinearBone->posetoboneindex - 36;

	// mult by two for: flags and parrents, rot and pos.
	int tableSize = ((sizeof(int) * 2) + (sizeof(Vector3) * 2) + sizeof(Quaternion) + sizeof(matrix3x4_t)) * newLinearBone->numbones;

	memcpy(g_model.pData, pOldLinearBoneTable, tableSize);
	g_model.pData += tableSize;

	ALIGN4(g_model.pData);
}

static void ConvertLinearBoneTableTo53(mstudiolinearbone_t* pOldLinearBone, char* pOldLinearBoneTable)
{
	printf("converting linear bone table...\n");

	g_model.hdrV53()->linearboneindex = g_model.pData - g_model.pBase;

	mstudiolinearbone_t* newLinearBone = reinterpret_cast<mstudiolinearbone_t*>(g_model.pData);
	g_model.pData += sizeof(mstudiolinearbone_t);

	newLinearBone->numbones = pOldLinearBone->numbones;
	newLinearBone->flagsindex = pOldLinearBone->flagsindex;
	newLinearBone->parentindex = pOldLinearBone->parentindex;
	newLinearBone->posindex = pOldLinearBone->posindex;
	newLinearBone->quatindex = pOldLinearBone->quatindex;
	newLinearBone->rotindex = pOldLinearBone->rotindex;
	newLinearBone->posetoboneindex = pOldLinearBone->posetoboneindex;

	// do it funky like this because posscale is not here in v53, and the indexes will still work
	newLinearBone->rotscaleindex = pOldLinearBone->posscaleindex;
	newLinearBone->qalignmentindex = pOldLinearBone->rotscaleindex;

	// mult by two for: flags and parrents, quat and qalignment.
	// mult by three for: pose, rot, and rotscale.
	int tableSize = ((sizeof(int) * 2) + (sizeof(Vector3) * 2) + (sizeof(Quaternion) * 1) + sizeof(matrix3x4_t)) * newLinearBone->numbones;

	memcpy(g_model.pData, pOldLinearBoneTable, tableSize);
	g_model.pData += tableSize;

	memcpy(g_model.pData, pOldLinearBoneTable + tableSize + (sizeof(Vector3) * newLinearBone->numbones), (sizeof(Vector3) + sizeof(Quaternion)) * newLinearBone->numbones);
	g_model.pData += (sizeof(Vector3) + sizeof(Quaternion)) * newLinearBone->numbones;

	ALIGN4(g_model.pData);
}